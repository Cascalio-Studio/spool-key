/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 *            For more information about which c-functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2020-2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>

#include "main.h"
#include <errno.h>
#include <sys/unistd.h>

/**
 * @brief External handle for UART interface
 */
extern UART_HandleTypeDef hlpuart1;


/* Variables */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));


char *__env[1] = { 0 };
char **environ = __env;

/*** Functions */

/**
 * @brief Initialize monitor handles
 * @details Stub implementation for semihosting - does nothing in embedded systems
 */
void initialise_monitor_handles()
{
}

/**
 * @brief Get process ID
 * @details Stub implementation - always returns 1 for embedded systems
 * @retval 1 Always returns process ID 1
 */
int _getpid(void)
{
  return 1;
}

/**
 * @brief Send signal to process
 * @details Stub implementation for embedded systems - always fails
 * @param pid - Process ID (ignored)
 * @param sig - Signal number (ignored)
 * @retval -1 Always returns error
 */
int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

/**
 * @brief Exit program
 * @details Stub implementation - calls _kill and hangs indefinitely
 * @param status - Exit status
 */
void _exit (int status)
{
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Write function wrapper
 * @details Transfers pointer and data size to the UART Transmit function
 * @param file - File descriptor (e.g., STDOUT_FILENO for stdout, STDERR_FILENO for stderr)
 * @param *ptr - Pointer to data
 * @param len - Length of data
 * @return Number of bytes written on success, -1 on error
 */
int _write(int file, char *ptr, int len)
{
    if (file == STDOUT_FILENO || file == STDERR_FILENO)
    {
    	HAL_UART_Transmit(&hlpuart1, (uint8_t*)ptr, len, 100);
        while(hlpuart1.gState != HAL_UART_STATE_READY) {
        }
        return len;
    }
    errno = EBADF;
    return -1;
}

/**
 * @brief Read function wrapper
 * @details Reads data from UART input (currently not implemented in this example)
 * @param file - File descriptor (e.g., STDIN_FILENO for stdin)
 * @param *ptr - Pointer to buffer where data should be stored
 * @param len - Maximum length of data to read
 * @retval Number of bytes read on success, -1 on error (currently returns 0)
 */
int _read(int file, char *ptr, int len)
{
    if (file == STDIN_FILENO) {
        // Optional: LPUART Input implementieren
        // HAL_UART_Receive(&hlpuart1, (uint8_t*)ptr, 1, HAL_MAX_DELAY);
        return 0;
    }
    errno = EBADF;
    return -1;
}


#ifdef __cplusplus
}
#endif

/**
 * @brief Close file descriptor
 * @details Stub implementation for embedded systems - always fails
 * @param file - File descriptor to close
 * @retval -1 Always returns error
 */
int _close(int file)
{
  (void)file;
  return -1;
}

/**
 * @brief Get file status
 * @details Stub implementation - sets mode to character device
 * @param file - File descriptor
 * @param st - Pointer to stat structure
 * @retval 0 Always succeeds
 */
int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

/**
 * @brief Check if file descriptor is a terminal
 * @details Stub implementation - always returns true for embedded systems
 * @param file - File descriptor to check
 * @retval 1 Always returns true (is a terminal)
 */
int _isatty(int file)
{
  (void)file;
  return 1;
}

/**
 * @brief Seek in file
 * @details Stub implementation for embedded systems - no seeking supported
 * @param file - File descriptor
 * @param ptr - Offset
 * @param dir - Direction (SEEK_SET, SEEK_CUR, SEEK_END)
 * @retval 0 Always succeeds (no actual seeking)
 */
int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

/**
 * @brief Open file
 * @details Stub implementation for embedded systems - always fails
 * @param path - Path to file
 * @param flags - Open flags
 * @retval -1 Always returns error
 */
int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

/**
 * @brief Wait for process
 * @details Stub implementation for embedded systems - no processes
 * @param status - Pointer to status
 * @retval -1 Always returns error
 */
int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

/**
 * @brief Unlink file
 * @details Stub implementation for embedded systems - always fails
 * @param name - File name to unlink
 * @retval -1 Always returns error
 */
int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

/**
 * @brief Get process times
 * @details Stub implementation for embedded systems - no process timing
 * @param buf - Pointer to tms structure
 * @retval -1 Always returns error
 */
int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

/**
 * @brief Get file status by name
 * @details Stub implementation - sets mode to character device
 * @param file - File name
 * @param st - Pointer to stat structure
 * @retval 0 Always succeeds
 */
int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

/**
 * @brief Create hard link
 * @details Stub implementation for embedded systems - always fails
 * @param old - Old file name
 * @param new - New file name
 * @retval -1 Always returns error
 */
int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

/**
 * @brief Fork process
 * @details Stub implementation for embedded systems - no forking
 * @retval -1 Always returns error
 */
int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

/**
 * @brief Execute program
 * @details Stub implementation for embedded systems - no exec
 * @param name - Program name
 * @param argv - Argument vector
 * @param env - Environment variables
 * @retval -1 Always returns error
 */
int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}
